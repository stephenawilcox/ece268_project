import numpy as np
import cupy as cp
import math
import time

#  Constants
rotation_offsets = cp.array([
    [ 0, 36,  3, 41, 18],
    [ 1, 44, 10, 45,  2],
    [62,  6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39,  8, 14],
])

rho_mask = cp.uint64((1 << 64) - 1)

round_constants = cp.array([
    0x0000000000000001, 0x0000000000008082, 0x800000000000808A, 0x8000000080008000,
    0x000000000000808B, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
    0x000000000000008A, 0x0000000000000088, 0x0000000080008009, 0x000000008000000A,
    0x000000008000808B, 0x800000000000008B, 0x8000000000008089, 0x8000000000008003,
    0x8000000000008002, 0x8000000000000080, 0x000000000000800A, 0x800000008000000A,
    0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008
], dtype=cp.uint64)

"""
    W - lane size (FIXED TO 64 FOR SHA3-256)
    
    B - permutation width. For standard implementations of SHA3-256, this is 1600 (FIXED TO 1600 FOR GPU VERSION)

    C - capacity such that r + c = b (where r is some positive integer, and b is the bit length used in the algorithm). For SHA3-256, the value c is 512. c can also be calculated as c = b - r(where r is some positive integer, and b is the bit length used in the algorithm). For SHA3-256, the value c is 512 (FIXED TO 512 FOR GPU VERSION).

    D - output length of the hash. For SHA3-256, the value of d is 256 (FIXED TO 256 FOR GPU VERSION)
"""
slice_dim = 5
W = 64
L = int(math.log2(W))
B = slice_dim*slice_dim*W
C = 512 
D = 256


bits_to_state_array_kernel = cp.ElementwiseKernel(
    in_params='raw uint8 bits',         
    out_params='uint8 state',       
    operation=r'''
      int idx = i;
      int remainder = idx % (slice_dim * W);

      int x = idx / (slice_dim * W);
      int y = remainder / W;
      int z = remainder % W;

      int input_idx = y * (slice_dim * W) + x * W + z;
      state = bits[input_idx];
    ''',
    name='bits_to_state_array_kernel',
    preamble=f'constexpr int slice_dim={slice_dim},  W={W};'
)

state_array_to_bits_kernel = cp.ElementwiseKernel(
    in_params='raw uint8 state',   # raw pointer to flattened state[x,y,z]
    out_params='uint8 bits',        # each thread writes one output bit
    operation=r'''
      int idx = i;
      int remainder = idx % (slice_dim * W);

      int x   = remainder / W;
      int y   = idx / (slice_dim * W);
      int z   = remainder % W;

      int input_idx = x * (slice_dim * W) + y * W + z;
      bits = state[input_idx];
    ''',
    name='state_array_to_bits_kernel',
    preamble=f'constexpr int slice_dim={slice_dim}, W={W};'
)

def bitsToStateArray(bits: cp.ndarray) -> cp.ndarray:
    """
    This function takes in an input string and outputs the form of it in bits.

    To form the state array we want, we can reshape the string into the desired state array form. Given a cupy bit array of 1600 bits (which is expected for Keccak-c), we want to reshape it to the desired 5x5xw format. Based on the description, we fill up each lane of w bits, and then place another lane of w bits right next to the previous lane. Doing this 5 times gives a plane. Stacking 5 planes will then give the state array. Doing a simple reshape in the shape we want will produce the desired structure, and swapaxes will make sure the data in each lane will remain contiguous

    INPUTS:

    bits - the input bit array

    w - The number of layers. w is 64 for b=1600

    OUTPUTS: 

    state_array - input bits arranged in the form of a 5x5xw state array

    """
    state_array = bits_to_state_array_kernel(bits, size=B)
    return state_array.reshape((slice_dim, slice_dim, W))


def stateArrayToBits(state_array: cp.ndarray) -> cp.ndarray:
    """
    This function takes in a state array as input and forms it into a bit array.

    To reform the state array back into a string, we need to make sure the lanes are processed correctly, and to do this the axes of the matrix are changed, so that when it is flattened, it will be in the order built into by the array. Once this is done, reshape flattens the matrix accordingly.

    INPUTS:

    state - the state array

    OUTPUTS: 

    bits - a bit string concatenation of all elements of the state_array

    """
    state_flat = state_array.ravel()
    bits  = state_array_to_bits_kernel(state_flat, size=B)
    return bits


# ROUND FUNCTIONS 
"""
The round functions are a series of functions that must be done sequentially to get the correct output. For more information on what each function does specifically, see the pdf linked at the top. Each function will take in a state array that holds the current state, as well as the depth of each lane (w) (aka the number of layers). 
"""


def theta(state_array: cp.ndarray) -> cp.ndarray:
    """
    Theta Changes:
        - For loops removed for array operations
        - Rotations offloaded onto GPU
    """
    s = cp.asarray(state_array)
    C_ = s[:, 0, :].copy()
    C_ ^= s[:, 1, :]
    C_ ^= s[:, 2, :]
    C_ ^= s[:, 3, :]
    C_ ^= s[:, 4, :]
    
    left  = cp.roll(C_,  1, axis=0)         # C[x-1, z]
    right = cp.roll(C_, -1, axis=0)         # C[x+1, z]
    right = cp.roll(right, 1, axis=1)       # rotate z â†’ C[x+1, z-1]
    D_    = left ^ right

    return s ^ D_[:, None, :]


def rho(state_array: cp.ndarray) -> cp.ndarray:
    """
    Rho improvements:
        - For loops removed for array operations
        - Using the bit positions of a lane, the indices to mix are calculated with the rotation offsets, and using this we can get the new state with a conditional rotation
    """
    z = cp.arange(W, dtype=cp.int64)
    idx = (z[None, None, :] - rotation_offsets[..., None]) % W
    return cp.take_along_axis(state_array, idx, axis=2)


def pi(state_array: cp.ndarray) -> cp.ndarray:
    """
    Pi improvements:
        - For loops removed for array operations
        - Build an index array for each direction, and define the operation for each index using the specification of pi
    """
    X, Y = cp.meshgrid(cp.arange(5), cp.arange(5), indexing='ij')
    src_x = (X + 3*Y) % 5    
    src_y = X                
    return state_array[src_x, src_y, :]

def chi(state_array: cp.ndarray) -> cp.ndarray:
    """
    Chi improvements:
        - For loops removed for array operations
        - Array rotations done directly to the array with subsequent xor as specified
    """
    a1 = cp.roll(state_array, shift=-1, axis=0) 
    a2 = cp.roll(state_array, shift=-2, axis=0)  

    return state_array ^ ((~a1) & a2)


def iota(state_array: cp.ndarray, i_r: int) -> cp.ndarray:
    """
    Iota improvements:
        - For loops removed for array operations
        - Once choosing a lane, modify base lane according to constant on each round
    """
    new = state_array.copy()
    rc = round_constants[i_r]
    z = cp.arange(W, dtype=cp.uint64)
    rc_bits = ((rc >> z) & cp.uint64(1)).astype(state_array.dtype)
    new[0, 0, :] ^= rc_bits
    return new


def round(state_array: cp.ndarray, i_r: int) -> cp.ndarray:
    """
    Rounds are done sequentially, so no improvements can be made.
    """
    after_theta = theta(state_array)
    after_rho = rho(after_theta)
    after_pi = pi(after_rho)
    after_chi = chi(after_pi)
    after_iota = iota(after_chi, i_r)
    return after_iota


def Keccak_p(input: cp.ndarray, n_r: int = 24) -> str:
    """
    Keccak_p calls must be done sequentially in this order
    """
    state_array = bitsToStateArray(input)
    for i_r in range(n_r):
        state_array = round(state_array, i_r)
    s = stateArrayToBits(state_array)
    return s


def pad10(x: int, m: int) -> cp.ndarray:
    """
    There isn't much change between padding in CPU and GPU.
    """

    j = (-m - 2) % x 
    zeros = cp.zeros(j, dtype=cp.uint8)
    one = cp.array([1], dtype=cp.uint8)
    pad = cp.concatenate([one, zeros, one], axis=0)
    return pad


def sponge(N: cp.ndarray) -> cp.ndarray:
    """
    Improvements: 
        - Calculations are done entirely on GPU
        - Steps done here are mostly analagous to the CPU implementation, since Step 6 is a sequential process.

    """
    r = B - C
    N = cp.asarray(N, dtype=cp.uint8)
    pad = pad10(r, N.size)
    P = cp.concatenate([N, pad]) 
    n = P.size // r
    S = cp.zeros(B, dtype=cp.uint8)            
    zeros_c = cp.zeros(C, dtype=cp.uint8)              
    intermediate = cp.empty(B, dtype=cp.uint8)          

    for i in range(n):
        intermediate[:r] = P[i*r:i*r + r]
        intermediate[r:] = zeros_c     
        S ^= intermediate              
        S = Keccak_p(S)      
    Z = S[:r]                   
    return Z[:D]                


def Keccak_c(msg: cp.ndarray) -> cp.ndarray:
    """
    This function computes Keccak[c] for some bit msg.

    INPUTS:
    msg - The given bit message for Keccak[c]. 

    OUTPUTS:

    result - the result for the given input for Keccak[c] in bits

    """
    result = sponge(msg)
    return result


def SHA3_hash_gpu(msg: str) -> str:
    # Convert to bits
    byte_data = cp.asarray(bytearray(msg, encoding='ascii'), dtype=cp.uint8)
    bit_data  = cp.unpackbits(byte_data, bitorder='little')
    # Append suffix
    suffix    = cp.array([0, 1], dtype=cp.uint8)
    bit_data  = cp.concatenate([bit_data, suffix])
    # Begin hash
    hash_bits = Keccak_c(bit_data)        
    # Convert back to bits
    hash_bytes = cp.packbits(hash_bits, bitorder='little')
    return hash_bytes.get().tobytes().hex()

# DEBUG
def print_state(state):
    """
        This function is used to see the state of the 3D state array whenever called.

        INPUTS:

        state - The current state array
    """
    for i, layer in enumerate(state):  # Enumerate layers
        print(f"Layer {i}:\n{layer}")

def test_state_array_conversions():
    b = 1600
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)
    start = time.perf_counter()
    a = bitsToStateArray(bit_arr)
    end = time.perf_counter()
    print(f"Elapsed: {end - start:.6f} seconds")
    print("####################################### STATE ARRAY TESTS ######################################\n")
    print_state(a)
    start2 = time.perf_counter()
    st = stateArrayToBits(a)
    end2 = time.perf_counter()
    print(f"Elapsed: {end2 - start2:.6f} seconds")
    print("The state array converted to string: \n", st)
    print("\n")
    print("####################################### STATE ARRAY TESTS ######################################\n")
    cp.savetxt("out.txt", st, fmt="%d",delimiter='', newline='')

def test_theta():
    b = 1600
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)
    a = bitsToStateArray(bit_arr)
    print("####################################### THETA TESTS ######################################\n")
    ex_theta = theta(a)
    print_state(ex_theta)
    print("####################################### THETA TESTS ######################################\n")

def test_rho():
    b = 1600
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)

    a = bitsToStateArray(bit_arr)
    print("####################################### RHO TESTS ######################################\n")
    start = time.perf_counter()
    ex_rho = rho(a)
    end = time.perf_counter()
    print_state(ex_rho)
    print(f"Elapsed: {end - start:.6f} seconds")
    
    print("####################################### RHO TESTS ######################################\n")

def test_pi():
    b = 1600
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)

    a = bitsToStateArray(bit_arr)
    print("####################################### PI TESTS ######################################\n")
    ex_pi = pi(a)
    print_state(ex_pi)
    
    print("####################################### PI TESTS ######################################\n")

def test_chi():
    b = 1600
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)

    a = bitsToStateArray(bit_arr)
    print("####################################### CHI TESTS ######################################\n")
    ex_chi = chi(a)
    print_state(ex_chi)
    
    print("####################################### CHI TESTS ######################################\n")

def test_iota():
    i_r = 1
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)

    a = bitsToStateArray(bit_arr)
    print("####################################### IOTA TESTS ######################################\n")
    ex_iota = iota(a, i_r)
    print_state(ex_iota)
    
    print("####################################### IOTA TESTS ######################################\n")

def test_round():
    test_bits="0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010"
    bits = np.array([int(ch) for ch in test_bits], dtype=np.uint8)
    a = bitsToStateArray(bits)
    ex_round = round(a, 1)
    print("####################################### ROUND TEST ######################################\n")
    print_state(ex_round)
    print("\n")
    print("####################################### ROUND TEST ######################################\n")

def test_Keccak_p():
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010

    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8

    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)
    out = Keccak_p(bit_arr)
    np.savetxt('out.txt', out)

def test_pad10():
    a = pad10(100, 7)
    print(a)


"""
    This function computes the SHA3-Keccak version of a message. 

    INPUTS:
    msg - the original message given as a string

    OUTPUT:

    hash - the final hash of the message given in bits
    """

def test_sponge():
    b = 1600
    c = 512
    d = 256
    test_bits=0b0111111110011101011100100111110100000111110101101101011111100001011001101010111011010111000011110100011111101010111000110100011000001110101110010101001001110010011110111111001010101000101110011101111001111110110011011110000111001100101000101000101111001001100010100010101010110101111101000110011000001001010110110000001100010001111101110111100110110010011101100111110110100011110110000000100000101101011101000001010000100011101000001111001010001110011001000100011010101110001111000000111001000001011100000100101011110011001001101110001111000110101001101010110001010010001001011000001101111100001101110111010000000011101011001111010110011101011111000110000000010000011010101110011100011001100110001110011000011101010001000010110101101011101111100110010101100011110011000010000100001100000011110001100011000100011100001000010111100000011010101101111100010000001110010000111110111101000000110101110111011100100100001010110111000001110000100000000010111100101011010101101011101110110011111101010110010110111001110100011111110010100001011010010000000010100011001001100110001000011110110010010010011011000111100011100011011001101101100011011100011011100100010001010110010000001001110011101010000000110100111100001110101011110100001011001100000011000010111100101100010100100010110001110001101100110100011110111001010100010010010000111000011000110101010000110111010010001111111001011011001011001000010001011011011111000010101011100111111101001110000100000110010001000101001010100001011111000100101101010000010000011101011100101101011010001101101010110110111000001001011111000011100011110110100110101001000010
    n_bits = test_bits.bit_length()  
    n_bytes = (n_bits + 7) // 8
    byts = test_bits.to_bytes(n_bytes)
    byte_arr = cp.asarray(bytearray(byts), dtype=cp.uint8)
    bit_arr = cp.unpackbits(byte_arr)

    out = sponge(bit_arr)
    print(out)


def main():
    # test_state_array_conversions()
    # test_theta()
    # test_rho()
    # test_pi()
    # test_chi()
    # test_iota()
    # test_round()        
    # test_Keccak_p()             
    # test_pad10()              
    # test_sponge()                       # PASSED

    test_str = "abc"
    start = time.perf_counter()
    hash = SHA3_hash_gpu(test_str)
    end = time.perf_counter()
    print(hash)
    print("GPU Hash completed in ", end - start, "seconds.")
    

if __name__ == "__main__":
    main()